{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/visibility.ts","../src/actions.ts","../src/validation.ts","../src/catalog.ts"],"sourcesContent":["// Types\nexport type {\n  DynamicValue,\n  DynamicString,\n  DynamicNumber,\n  DynamicBoolean,\n  UIElement,\n  UITree,\n  VisibilityCondition,\n  LogicExpression,\n  AuthState,\n  DataModel,\n  ComponentSchema,\n  ValidationMode,\n  PatchOp,\n  JsonPatch,\n} from \"./types\";\n\nexport {\n  DynamicValueSchema,\n  DynamicStringSchema,\n  DynamicNumberSchema,\n  DynamicBooleanSchema,\n  resolveDynamicValue,\n  getByPath,\n  setByPath,\n} from \"./types\";\n\n// Visibility\nexport type { VisibilityContext } from \"./visibility\";\n\nexport {\n  VisibilityConditionSchema,\n  LogicExpressionSchema,\n  evaluateVisibility,\n  evaluateLogicExpression,\n  visibility,\n} from \"./visibility\";\n\n// Actions\nexport type {\n  Action,\n  ActionConfirm,\n  ActionOnSuccess,\n  ActionOnError,\n  ActionHandler,\n  ActionDefinition,\n  ResolvedAction,\n  ActionExecutionContext,\n} from \"./actions\";\n\nexport {\n  ActionSchema,\n  ActionConfirmSchema,\n  ActionOnSuccessSchema,\n  ActionOnErrorSchema,\n  resolveAction,\n  executeAction,\n  interpolateString,\n  action,\n} from \"./actions\";\n\n// Validation\nexport type {\n  ValidationCheck,\n  ValidationConfig,\n  ValidationFunction,\n  ValidationFunctionDefinition,\n  ValidationCheckResult,\n  ValidationResult,\n  ValidationContext,\n} from \"./validation\";\n\nexport {\n  ValidationCheckSchema,\n  ValidationConfigSchema,\n  builtInValidationFunctions,\n  runValidationCheck,\n  runValidation,\n  check,\n} from \"./validation\";\n\n// Catalog\nexport type {\n  ComponentDefinition,\n  CatalogConfig,\n  Catalog,\n  InferCatalogComponentProps,\n} from \"./catalog\";\n\nexport { createCatalog, generateCatalogPrompt } from \"./catalog\";\n","import { z } from \"zod\";\n\n/**\n * Dynamic value - can be a literal or a path reference to data model\n */\nexport type DynamicValue<T = unknown> = T | { path: string };\n\n/**\n * Dynamic string value\n */\nexport type DynamicString = DynamicValue<string>;\n\n/**\n * Dynamic number value\n */\nexport type DynamicNumber = DynamicValue<number>;\n\n/**\n * Dynamic boolean value\n */\nexport type DynamicBoolean = DynamicValue<boolean>;\n\n/**\n * Zod schema for dynamic values\n */\nexport const DynamicValueSchema = z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicStringSchema = z.union([\n  z.string(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicNumberSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicBooleanSchema = z.union([\n  z.boolean(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Base UI element structure for v2\n */\nexport interface UIElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> {\n  /** Unique key for reconciliation */\n  key: string;\n  /** Component type from the catalog */\n  type: T;\n  /** Component props */\n  props: P;\n  /** Child element keys (flat structure) */\n  children?: string[];\n  /** Parent element key (null for root) */\n  parentKey?: string | null;\n  /** Visibility condition */\n  visible?: VisibilityCondition;\n}\n\n/**\n * Visibility condition types\n */\nexport type VisibilityCondition =\n  | boolean\n  | { path: string }\n  | { auth: \"signedIn\" | \"signedOut\" }\n  | LogicExpression;\n\n/**\n * Logic expression for complex conditions\n */\nexport type LogicExpression =\n  | { and: LogicExpression[] }\n  | { or: LogicExpression[] }\n  | { not: LogicExpression }\n  | { path: string }\n  | { eq: [DynamicValue, DynamicValue] }\n  | { neq: [DynamicValue, DynamicValue] }\n  | { gt: [DynamicValue<number>, DynamicValue<number>] }\n  | { gte: [DynamicValue<number>, DynamicValue<number>] }\n  | { lt: [DynamicValue<number>, DynamicValue<number>] }\n  | { lte: [DynamicValue<number>, DynamicValue<number>] };\n\n/**\n * Flat UI tree structure (optimized for LLM generation)\n */\nexport interface UITree {\n  /** Root element key */\n  root: string;\n  /** Flat map of elements by key */\n  elements: Record<string, UIElement>;\n}\n\n/**\n * Auth state for visibility evaluation\n */\nexport interface AuthState {\n  isSignedIn: boolean;\n  user?: Record<string, unknown>;\n}\n\n/**\n * Data model type\n */\nexport type DataModel = Record<string, unknown>;\n\n/**\n * Component schema definition using Zod\n */\nexport type ComponentSchema = z.ZodType<Record<string, unknown>>;\n\n/**\n * Validation mode for catalog validation\n */\nexport type ValidationMode = \"strict\" | \"warn\" | \"ignore\";\n\n/**\n * JSON patch operation types\n */\nexport type PatchOp = \"add\" | \"remove\" | \"replace\" | \"set\";\n\n/**\n * JSON patch operation\n */\nexport interface JsonPatch {\n  op: PatchOp;\n  path: string;\n  value?: unknown;\n}\n\n/**\n * Resolve a dynamic value against a data model\n */\nexport function resolveDynamicValue<T>(\n  value: DynamicValue<T>,\n  dataModel: DataModel,\n): T | undefined {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"object\" && \"path\" in value) {\n    return getByPath(dataModel, value.path) as T | undefined;\n  }\n\n  return value as T;\n}\n\n/**\n * Get a value from an object by JSON Pointer path\n */\nexport function getByPath(obj: unknown, path: string): unknown {\n  if (!path || path === \"/\") {\n    return obj;\n  }\n\n  const segments = path.startsWith(\"/\")\n    ? path.slice(1).split(\"/\")\n    : path.split(\"/\");\n\n  let current: unknown = obj;\n\n  for (const segment of segments) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (typeof current === \"object\") {\n      current = (current as Record<string, unknown>)[segment];\n    } else {\n      return undefined;\n    }\n  }\n\n  return current;\n}\n\n/**\n * Set a value in an object by JSON Pointer path\n */\nexport function setByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = path.startsWith(\"/\")\n    ? path.slice(1).split(\"/\")\n    : path.split(\"/\");\n\n  if (segments.length === 0) return;\n\n  let current: Record<string, unknown> = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    if (!(segment in current) || typeof current[segment] !== \"object\") {\n      current[segment] = {};\n    }\n    current = current[segment] as Record<string, unknown>;\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n  current[lastSegment] = value;\n}\n","import { z } from \"zod\";\nimport type {\n  VisibilityCondition,\n  LogicExpression,\n  DataModel,\n  AuthState,\n  DynamicValue,\n} from \"./types\";\nimport { resolveDynamicValue, DynamicValueSchema } from \"./types\";\n\n// Dynamic value schema for comparisons (number-focused)\nconst DynamicNumberValueSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Logic expression schema (recursive)\n * Using a more permissive schema that aligns with runtime behavior\n */\nexport const LogicExpressionSchema: z.ZodType<LogicExpression> = z.lazy(() =>\n  z.union([\n    z.object({ and: z.array(LogicExpressionSchema) }),\n    z.object({ or: z.array(LogicExpressionSchema) }),\n    z.object({ not: LogicExpressionSchema }),\n    z.object({ path: z.string() }),\n    z.object({ eq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({ neq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({\n      gt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      gte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n  ]),\n) as z.ZodType<LogicExpression>;\n\n/**\n * Visibility condition schema\n */\nexport const VisibilityConditionSchema: z.ZodType<VisibilityCondition> =\n  z.union([\n    z.boolean(),\n    z.object({ path: z.string() }),\n    z.object({ auth: z.enum([\"signedIn\", \"signedOut\"]) }),\n    LogicExpressionSchema,\n  ]);\n\n/**\n * Context for evaluating visibility\n */\nexport interface VisibilityContext {\n  dataModel: DataModel;\n  authState?: AuthState;\n}\n\n/**\n * Evaluate a logic expression against data and auth state\n */\nexport function evaluateLogicExpression(\n  expr: LogicExpression,\n  ctx: VisibilityContext,\n): boolean {\n  const { dataModel } = ctx;\n\n  // AND expression\n  if (\"and\" in expr) {\n    return expr.and.every((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // OR expression\n  if (\"or\" in expr) {\n    return expr.or.some((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // NOT expression\n  if (\"not\" in expr) {\n    return !evaluateLogicExpression(expr.not, ctx);\n  }\n\n  // Path expression (resolve to boolean)\n  if (\"path\" in expr) {\n    const value = resolveDynamicValue({ path: expr.path }, dataModel);\n    return Boolean(value);\n  }\n\n  // Equality comparison\n  if (\"eq\" in expr) {\n    const [left, right] = expr.eq;\n    const leftValue = resolveDynamicValue(left, dataModel);\n    const rightValue = resolveDynamicValue(right, dataModel);\n    return leftValue === rightValue;\n  }\n\n  // Not equal comparison\n  if (\"neq\" in expr) {\n    const [left, right] = expr.neq;\n    const leftValue = resolveDynamicValue(left, dataModel);\n    const rightValue = resolveDynamicValue(right, dataModel);\n    return leftValue !== rightValue;\n  }\n\n  // Greater than\n  if (\"gt\" in expr) {\n    const [left, right] = expr.gt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue > rightValue;\n    }\n    return false;\n  }\n\n  // Greater than or equal\n  if (\"gte\" in expr) {\n    const [left, right] = expr.gte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue >= rightValue;\n    }\n    return false;\n  }\n\n  // Less than\n  if (\"lt\" in expr) {\n    const [left, right] = expr.lt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue < rightValue;\n    }\n    return false;\n  }\n\n  // Less than or equal\n  if (\"lte\" in expr) {\n    const [left, right] = expr.lte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue <= rightValue;\n    }\n    return false;\n  }\n\n  return false;\n}\n\n/**\n * Evaluate a visibility condition\n */\nexport function evaluateVisibility(\n  condition: VisibilityCondition | undefined,\n  ctx: VisibilityContext,\n): boolean {\n  // No condition = visible\n  if (condition === undefined) {\n    return true;\n  }\n\n  // Boolean literal\n  if (typeof condition === \"boolean\") {\n    return condition;\n  }\n\n  // Path reference\n  if (\"path\" in condition && !(\"and\" in condition) && !(\"or\" in condition)) {\n    const value = resolveDynamicValue({ path: condition.path }, ctx.dataModel);\n    return Boolean(value);\n  }\n\n  // Auth condition\n  if (\"auth\" in condition) {\n    const isSignedIn = ctx.authState?.isSignedIn ?? false;\n    if (condition.auth === \"signedIn\") {\n      return isSignedIn;\n    }\n    if (condition.auth === \"signedOut\") {\n      return !isSignedIn;\n    }\n    return false;\n  }\n\n  // Logic expression\n  return evaluateLogicExpression(condition as LogicExpression, ctx);\n}\n\n/**\n * Helper to create visibility conditions\n */\nexport const visibility = {\n  /** Always visible */\n  always: true as const,\n\n  /** Never visible */\n  never: false as const,\n\n  /** Visible when path is truthy */\n  when: (path: string): VisibilityCondition => ({ path }),\n\n  /** Visible when signed in */\n  signedIn: { auth: \"signedIn\" } as const,\n\n  /** Visible when signed out */\n  signedOut: { auth: \"signedOut\" } as const,\n\n  /** AND multiple conditions */\n  and: (...conditions: LogicExpression[]): LogicExpression => ({\n    and: conditions,\n  }),\n\n  /** OR multiple conditions */\n  or: (...conditions: LogicExpression[]): LogicExpression => ({\n    or: conditions,\n  }),\n\n  /** NOT a condition */\n  not: (condition: LogicExpression): LogicExpression => ({ not: condition }),\n\n  /** Equality check */\n  eq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    eq: [left, right],\n  }),\n\n  /** Not equal check */\n  neq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    neq: [left, right],\n  }),\n\n  /** Greater than */\n  gt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gt: [left, right] }),\n\n  /** Greater than or equal */\n  gte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gte: [left, right] }),\n\n  /** Less than */\n  lt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lt: [left, right] }),\n\n  /** Less than or equal */\n  lte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lte: [left, right] }),\n};\n","import { z } from \"zod\";\nimport type { DynamicValue, DataModel } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\n\n/**\n * Confirmation dialog configuration\n */\nexport interface ActionConfirm {\n  title: string;\n  message: string;\n  confirmLabel?: string;\n  cancelLabel?: string;\n  variant?: \"default\" | \"danger\";\n}\n\n/**\n * Action success handler\n */\nexport type ActionOnSuccess =\n  | { navigate: string }\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action error handler\n */\nexport type ActionOnError =\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Rich action definition\n */\nexport interface Action {\n  /** Action name (must be in catalog) */\n  name: string;\n  /** Parameters to pass to the action handler */\n  params?: Record<string, DynamicValue>;\n  /** Confirmation dialog before execution */\n  confirm?: ActionConfirm;\n  /** Handler after successful execution */\n  onSuccess?: ActionOnSuccess;\n  /** Handler after failed execution */\n  onError?: ActionOnError;\n}\n\n/**\n * Schema for action confirmation\n */\nexport const ActionConfirmSchema = z.object({\n  title: z.string(),\n  message: z.string(),\n  confirmLabel: z.string().optional(),\n  cancelLabel: z.string().optional(),\n  variant: z.enum([\"default\", \"danger\"]).optional(),\n});\n\n/**\n * Schema for success handlers\n */\nexport const ActionOnSuccessSchema = z.union([\n  z.object({ navigate: z.string() }),\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Schema for error handlers\n */\nexport const ActionOnErrorSchema = z.union([\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Full action schema\n */\nexport const ActionSchema = z.object({\n  name: z.string(),\n  params: z.record(z.string(), DynamicValueSchema).optional(),\n  confirm: ActionConfirmSchema.optional(),\n  onSuccess: ActionOnSuccessSchema.optional(),\n  onError: ActionOnErrorSchema.optional(),\n});\n\n/**\n * Action handler function signature\n */\nexport type ActionHandler<\n  TParams = Record<string, unknown>,\n  TResult = unknown,\n> = (params: TParams) => Promise<TResult> | TResult;\n\n/**\n * Action definition in catalog\n */\nexport interface ActionDefinition<TParams = Record<string, unknown>> {\n  /** Zod schema for params validation */\n  params?: z.ZodType<TParams>;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Resolved action with all dynamic values resolved\n */\nexport interface ResolvedAction {\n  name: string;\n  params: Record<string, unknown>;\n  confirm?: ActionConfirm;\n  onSuccess?: ActionOnSuccess;\n  onError?: ActionOnError;\n}\n\n/**\n * Resolve all dynamic values in an action\n */\nexport function resolveAction(\n  action: Action,\n  dataModel: DataModel,\n): ResolvedAction {\n  const resolvedParams: Record<string, unknown> = {};\n\n  if (action.params) {\n    for (const [key, value] of Object.entries(action.params)) {\n      resolvedParams[key] = resolveDynamicValue(value, dataModel);\n    }\n  }\n\n  // Interpolate confirmation message if present\n  let confirm = action.confirm;\n  if (confirm) {\n    confirm = {\n      ...confirm,\n      message: interpolateString(confirm.message, dataModel),\n      title: interpolateString(confirm.title, dataModel),\n    };\n  }\n\n  return {\n    name: action.name,\n    params: resolvedParams,\n    confirm,\n    onSuccess: action.onSuccess,\n    onError: action.onError,\n  };\n}\n\n/**\n * Interpolate ${path} expressions in a string\n */\nexport function interpolateString(\n  template: string,\n  dataModel: DataModel,\n): string {\n  return template.replace(/\\$\\{([^}]+)\\}/g, (_, path) => {\n    const value = resolveDynamicValue({ path }, dataModel);\n    return String(value ?? \"\");\n  });\n}\n\n/**\n * Context for action execution\n */\nexport interface ActionExecutionContext {\n  /** The resolved action */\n  action: ResolvedAction;\n  /** The action handler from the host */\n  handler: ActionHandler;\n  /** Function to update data model */\n  setData: (path: string, value: unknown) => void;\n  /** Function to navigate */\n  navigate?: (path: string) => void;\n  /** Function to execute another action */\n  executeAction?: (name: string) => Promise<void>;\n}\n\n/**\n * Execute an action with all callbacks\n */\nexport async function executeAction(\n  ctx: ActionExecutionContext,\n): Promise<void> {\n  const { action, handler, setData, navigate, executeAction } = ctx;\n\n  try {\n    await handler(action.params);\n\n    // Handle success\n    if (action.onSuccess) {\n      if (\"navigate\" in action.onSuccess && navigate) {\n        navigate(action.onSuccess.navigate);\n      } else if (\"set\" in action.onSuccess) {\n        for (const [path, value] of Object.entries(action.onSuccess.set)) {\n          setData(path, value);\n        }\n      } else if (\"action\" in action.onSuccess && executeAction) {\n        await executeAction(action.onSuccess.action);\n      }\n    }\n  } catch (error) {\n    // Handle error\n    if (action.onError) {\n      if (\"set\" in action.onError) {\n        for (const [path, value] of Object.entries(action.onError.set)) {\n          // Replace $error.message with actual error\n          const resolvedValue =\n            typeof value === \"string\" && value === \"$error.message\"\n              ? (error as Error).message\n              : value;\n          setData(path, resolvedValue);\n        }\n      } else if (\"action\" in action.onError && executeAction) {\n        await executeAction(action.onError.action);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Helper to create actions\n */\nexport const action = {\n  /** Create a simple action */\n  simple: (name: string, params?: Record<string, DynamicValue>): Action => ({\n    name,\n    params,\n  }),\n\n  /** Create an action with confirmation */\n  withConfirm: (\n    name: string,\n    confirm: ActionConfirm,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    confirm,\n  }),\n\n  /** Create an action with success handler */\n  withSuccess: (\n    name: string,\n    onSuccess: ActionOnSuccess,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    onSuccess,\n  }),\n};\n","import { z } from \"zod\";\nimport type { DynamicValue, DataModel, LogicExpression } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\nimport { LogicExpressionSchema, evaluateLogicExpression } from \"./visibility\";\n\n/**\n * Validation check definition\n */\nexport interface ValidationCheck {\n  /** Function name (built-in or from catalog) */\n  fn: string;\n  /** Additional arguments for the function */\n  args?: Record<string, DynamicValue>;\n  /** Error message to display if check fails */\n  message: string;\n}\n\n/**\n * Validation configuration for a field\n */\nexport interface ValidationConfig {\n  /** Array of checks to run */\n  checks?: ValidationCheck[];\n  /** When to run validation */\n  validateOn?: \"change\" | \"blur\" | \"submit\";\n  /** Condition for when validation is enabled */\n  enabled?: LogicExpression;\n}\n\n/**\n * Schema for validation check\n */\nexport const ValidationCheckSchema = z.object({\n  fn: z.string(),\n  args: z.record(z.string(), DynamicValueSchema).optional(),\n  message: z.string(),\n});\n\n/**\n * Schema for validation config\n */\nexport const ValidationConfigSchema = z.object({\n  checks: z.array(ValidationCheckSchema).optional(),\n  validateOn: z.enum([\"change\", \"blur\", \"submit\"]).optional(),\n  enabled: LogicExpressionSchema.optional(),\n});\n\n/**\n * Validation function signature\n */\nexport type ValidationFunction = (\n  value: unknown,\n  args?: Record<string, unknown>,\n) => boolean;\n\n/**\n * Validation function definition in catalog\n */\nexport interface ValidationFunctionDefinition {\n  /** The validation function */\n  validate: ValidationFunction;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Built-in validation functions\n */\nexport const builtInValidationFunctions: Record<string, ValidationFunction> = {\n  /**\n   * Check if value is not null, undefined, or empty string\n   */\n  required: (value: unknown) => {\n    if (value === null || value === undefined) return false;\n    if (typeof value === \"string\") return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n\n  /**\n   * Check if value is a valid email address\n   */\n  email: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  },\n\n  /**\n   * Check minimum string length\n   */\n  minLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value.length >= min;\n  },\n\n  /**\n   * Check maximum string length\n   */\n  maxLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value.length <= max;\n  },\n\n  /**\n   * Check if string matches a regex pattern\n   */\n  pattern: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const pattern = args?.pattern;\n    if (typeof pattern !== \"string\") return false;\n    try {\n      return new RegExp(pattern).test(value);\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check minimum numeric value\n   */\n  min: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value >= min;\n  },\n\n  /**\n   * Check maximum numeric value\n   */\n  max: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value <= max;\n  },\n\n  /**\n   * Check if value is a number\n   */\n  numeric: (value: unknown) => {\n    if (typeof value === \"number\") return !isNaN(value);\n    if (typeof value === \"string\") return !isNaN(parseFloat(value));\n    return false;\n  },\n\n  /**\n   * Check if value is a valid URL\n   */\n  url: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check if value matches another field\n   */\n  matches: (value: unknown, args?: Record<string, unknown>) => {\n    const other = args?.other;\n    return value === other;\n  },\n};\n\n/**\n * Validation result for a single check\n */\nexport interface ValidationCheckResult {\n  fn: string;\n  valid: boolean;\n  message: string;\n}\n\n/**\n * Full validation result for a field\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  checks: ValidationCheckResult[];\n}\n\n/**\n * Context for running validation\n */\nexport interface ValidationContext {\n  /** Current value to validate */\n  value: unknown;\n  /** Full data model for resolving paths */\n  dataModel: DataModel;\n  /** Custom validation functions from catalog */\n  customFunctions?: Record<string, ValidationFunction>;\n}\n\n/**\n * Run a single validation check\n */\nexport function runValidationCheck(\n  check: ValidationCheck,\n  ctx: ValidationContext,\n): ValidationCheckResult {\n  const { value, dataModel, customFunctions } = ctx;\n\n  // Resolve args\n  const resolvedArgs: Record<string, unknown> = {};\n  if (check.args) {\n    for (const [key, argValue] of Object.entries(check.args)) {\n      resolvedArgs[key] = resolveDynamicValue(argValue, dataModel);\n    }\n  }\n\n  // Find the validation function\n  const fn =\n    builtInValidationFunctions[check.fn] ?? customFunctions?.[check.fn];\n\n  if (!fn) {\n    console.warn(`Unknown validation function: ${check.fn}`);\n    return {\n      fn: check.fn,\n      valid: true, // Don't fail on unknown functions\n      message: check.message,\n    };\n  }\n\n  const valid = fn(value, resolvedArgs);\n\n  return {\n    fn: check.fn,\n    valid,\n    message: check.message,\n  };\n}\n\n/**\n * Run all validation checks for a field\n */\nexport function runValidation(\n  config: ValidationConfig,\n  ctx: ValidationContext & { authState?: { isSignedIn: boolean } },\n): ValidationResult {\n  const checks: ValidationCheckResult[] = [];\n  const errors: string[] = [];\n\n  // Check if validation is enabled\n  if (config.enabled) {\n    const enabled = evaluateLogicExpression(config.enabled, {\n      dataModel: ctx.dataModel,\n      authState: ctx.authState,\n    });\n    if (!enabled) {\n      return { valid: true, errors: [], checks: [] };\n    }\n  }\n\n  // Run each check\n  if (config.checks) {\n    for (const check of config.checks) {\n      const result = runValidationCheck(check, ctx);\n      checks.push(result);\n      if (!result.valid) {\n        errors.push(result.message);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    checks,\n  };\n}\n\n/**\n * Helper to create validation checks\n */\nexport const check = {\n  required: (message = \"This field is required\"): ValidationCheck => ({\n    fn: \"required\",\n    message,\n  }),\n\n  email: (message = \"Invalid email address\"): ValidationCheck => ({\n    fn: \"email\",\n    message,\n  }),\n\n  minLength: (min: number, message?: string): ValidationCheck => ({\n    fn: \"minLength\",\n    args: { min },\n    message: message ?? `Must be at least ${min} characters`,\n  }),\n\n  maxLength: (max: number, message?: string): ValidationCheck => ({\n    fn: \"maxLength\",\n    args: { max },\n    message: message ?? `Must be at most ${max} characters`,\n  }),\n\n  pattern: (pattern: string, message = \"Invalid format\"): ValidationCheck => ({\n    fn: \"pattern\",\n    args: { pattern },\n    message,\n  }),\n\n  min: (min: number, message?: string): ValidationCheck => ({\n    fn: \"min\",\n    args: { min },\n    message: message ?? `Must be at least ${min}`,\n  }),\n\n  max: (max: number, message?: string): ValidationCheck => ({\n    fn: \"max\",\n    args: { max },\n    message: message ?? `Must be at most ${max}`,\n  }),\n\n  url: (message = \"Invalid URL\"): ValidationCheck => ({\n    fn: \"url\",\n    message,\n  }),\n\n  matches: (\n    otherPath: string,\n    message = \"Fields must match\",\n  ): ValidationCheck => ({\n    fn: \"matches\",\n    args: { other: { path: otherPath } },\n    message,\n  }),\n};\n","import { z } from \"zod\";\nimport type {\n  ComponentSchema,\n  ValidationMode,\n  UIElement,\n  UITree,\n  VisibilityCondition,\n} from \"./types\";\nimport { VisibilityConditionSchema } from \"./visibility\";\nimport { ActionSchema, type ActionDefinition } from \"./actions\";\nimport { ValidationConfigSchema, type ValidationFunction } from \"./validation\";\n\n/**\n * Component definition with visibility and validation support\n */\nexport interface ComponentDefinition<\n  TProps extends ComponentSchema = ComponentSchema,\n> {\n  /** Zod schema for component props */\n  props: TProps;\n  /** Whether this component can have children */\n  hasChildren?: boolean;\n  /** Description for AI generation */\n  description?: string;\n}\n\n/**\n * Catalog configuration\n */\nexport interface CatalogConfig<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  name?: string;\n  /** Component definitions */\n  components: TComponents;\n  /** Action definitions with param schemas */\n  actions?: TActions;\n  /** Custom validation functions */\n  functions?: TFunctions;\n  /** Validation mode */\n  validation?: ValidationMode;\n}\n\n/**\n * Catalog instance\n */\nexport interface Catalog<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  readonly name: string;\n  /** Component names */\n  readonly componentNames: (keyof TComponents)[];\n  /** Action names */\n  readonly actionNames: (keyof TActions)[];\n  /** Function names */\n  readonly functionNames: (keyof TFunctions)[];\n  /** Validation mode */\n  readonly validation: ValidationMode;\n  /** Component definitions */\n  readonly components: TComponents;\n  /** Action definitions */\n  readonly actions: TActions;\n  /** Custom validation functions */\n  readonly functions: TFunctions;\n  /** Full element schema for AI generation */\n  readonly elementSchema: z.ZodType<UIElement>;\n  /** Full UI tree schema */\n  readonly treeSchema: z.ZodType<UITree>;\n  /** Check if component exists */\n  hasComponent(type: string): boolean;\n  /** Check if action exists */\n  hasAction(name: string): boolean;\n  /** Check if function exists */\n  hasFunction(name: string): boolean;\n  /** Validate an element */\n  validateElement(element: unknown): {\n    success: boolean;\n    data?: UIElement;\n    error?: z.ZodError;\n  };\n  /** Validate a UI tree */\n  validateTree(tree: unknown): {\n    success: boolean;\n    data?: UITree;\n    error?: z.ZodError;\n  };\n}\n\n/**\n * Create a v2 catalog with visibility, actions, and validation support\n */\nexport function createCatalog<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n>(\n  config: CatalogConfig<TComponents, TActions, TFunctions>,\n): Catalog<TComponents, TActions, TFunctions> {\n  const {\n    name = \"unnamed\",\n    components,\n    actions = {} as TActions,\n    functions = {} as TFunctions,\n    validation = \"strict\",\n  } = config;\n\n  const componentNames = Object.keys(components) as (keyof TComponents)[];\n  const actionNames = Object.keys(actions) as (keyof TActions)[];\n  const functionNames = Object.keys(functions) as (keyof TFunctions)[];\n\n  // Create element schema for each component type\n  const componentSchemas = componentNames.map((componentName) => {\n    const def = components[componentName]!;\n\n    return z.object({\n      key: z.string(),\n      type: z.literal(componentName as string),\n      props: def.props,\n      children: z.array(z.string()).optional(),\n      parentKey: z.string().nullable().optional(),\n      visible: VisibilityConditionSchema.optional(),\n    });\n  });\n\n  // Create union schema for all components\n  let elementSchema: z.ZodType<UIElement>;\n\n  if (componentSchemas.length === 0) {\n    elementSchema = z.object({\n      key: z.string(),\n      type: z.string(),\n      props: z.record(z.string(), z.unknown()),\n      children: z.array(z.string()).optional(),\n      parentKey: z.string().nullable().optional(),\n      visible: VisibilityConditionSchema.optional(),\n    }) as unknown as z.ZodType<UIElement>;\n  } else if (componentSchemas.length === 1) {\n    elementSchema = componentSchemas[0] as unknown as z.ZodType<UIElement>;\n  } else {\n    elementSchema = z.discriminatedUnion(\"type\", [\n      componentSchemas[0] as z.ZodObject<any>,\n      componentSchemas[1] as z.ZodObject<any>,\n      ...(componentSchemas.slice(2) as z.ZodObject<any>[]),\n    ]) as unknown as z.ZodType<UIElement>;\n  }\n\n  // Create tree schema\n  const treeSchema = z.object({\n    root: z.string(),\n    elements: z.record(z.string(), elementSchema),\n  }) as unknown as z.ZodType<UITree>;\n\n  return {\n    name,\n    componentNames,\n    actionNames,\n    functionNames,\n    validation,\n    components,\n    actions,\n    functions,\n    elementSchema,\n    treeSchema,\n\n    hasComponent(type: string) {\n      return type in components;\n    },\n\n    hasAction(name: string) {\n      return name in actions;\n    },\n\n    hasFunction(name: string) {\n      return name in functions;\n    },\n\n    validateElement(element: unknown) {\n      const result = elementSchema.safeParse(element);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n\n    validateTree(tree: unknown) {\n      const result = treeSchema.safeParse(tree);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n  };\n}\n\n/**\n * Generate a prompt for AI that describes the catalog\n */\nexport function generateCatalogPrompt<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition>,\n  TFunctions extends Record<string, ValidationFunction>,\n>(catalog: Catalog<TComponents, TActions, TFunctions>): string {\n  const lines: string[] = [\n    `# ${catalog.name} Component Catalog`,\n    \"\",\n    \"## Available Components\",\n    \"\",\n  ];\n\n  // Components\n  for (const name of catalog.componentNames) {\n    const def = catalog.components[name]!;\n    lines.push(`### ${String(name)}`);\n    if (def.description) {\n      lines.push(def.description);\n    }\n    lines.push(\"\");\n  }\n\n  // Actions\n  if (catalog.actionNames.length > 0) {\n    lines.push(\"## Available Actions\");\n    lines.push(\"\");\n    for (const name of catalog.actionNames) {\n      const def = catalog.actions[name]!;\n      lines.push(\n        `- \\`${String(name)}\\`${def.description ? `: ${def.description}` : \"\"}`,\n      );\n    }\n    lines.push(\"\");\n  }\n\n  // Visibility\n  lines.push(\"## Visibility Conditions\");\n  lines.push(\"\");\n  lines.push(\"Components can have a `visible` property:\");\n  lines.push(\"- `true` / `false` - Always visible/hidden\");\n  lines.push('- `{ \"path\": \"/data/path\" }` - Visible when path is truthy');\n  lines.push('- `{ \"auth\": \"signedIn\" }` - Visible when user is signed in');\n  lines.push('- `{ \"and\": [...] }` - All conditions must be true');\n  lines.push('- `{ \"or\": [...] }` - Any condition must be true');\n  lines.push('- `{ \"not\": {...} }` - Negates a condition');\n  lines.push('- `{ \"eq\": [a, b] }` - Equality check');\n  lines.push(\"\");\n\n  // Validation\n  lines.push(\"## Validation Functions\");\n  lines.push(\"\");\n  lines.push(\n    \"Built-in: `required`, `email`, `minLength`, `maxLength`, `pattern`, `min`, `max`, `url`\",\n  );\n  if (catalog.functionNames.length > 0) {\n    lines.push(`Custom: ${catalog.functionNames.map(String).join(\", \")}`);\n  }\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Type helper to infer component props from catalog\n */\nexport type InferCatalogComponentProps<\n  C extends Catalog<Record<string, ComponentDefinition>>,\n> = {\n  [K in keyof C[\"components\"]]: z.infer<C[\"components\"][K][\"props\"]>;\n};\n"],"mappings":"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","names":["import_zod","import_zod","action","executeAction","import_zod","check","import_zod","name"]}